# Alpaca Broker API at socii

Alpaca have released an [OpenAPI]() schema of their api at on their [bkdocs github repo](https://github.com/alpacahq/bkdocs/blob/master/assets/openapi.yaml).

Using [datamodel-code-generator](https://koxudaxi.github.io/datamodel-code-generator/) & [fastapi-code-generator](https://github.com/koxudaxi/fastapi-code-generator) we generated server-side fastapi code for the api.

Using [openapi-code-generator](https://openapi-generator.tech/docs/installation/) a client-side typescript api implementation was generated.

Finally using [SwaggerHub Alpaca Broker API hosted converter](https://app.swaggerhub.com/apis/Investing-App/alpaca-broker_api/1.0.0#/) some execellent client-side python code was generated. Complete with docs & test suite!

# Proposal for use of the generated code

Client-side calls which do not require extra business logic can simply use the generated
typescript code in the `ts` folder. Although this would need to be moved into the frontend
`app` folder.

For server-side code we have multiple ways to proceed:

- Use the same code from vercel functions. Which would require building business logic
  around the generated api clients.
  - This would allow us to simply host the code in one place (the same folder as the frontend, say in `lib`).
  - The generated typescript api is very easy to work with.
  - We would have to create our own test suite from scratch.
- Replicate code in the `functions` for use in Firebase functions.
  - Simple variation on the above except the code would not be called through some api call like
    `socii.app/api/alpaca/createAccount` & instead could be triggered by any of the available firebase triggers.
  - Again we would have to create our own test suite from scratch.
- Convert the python api into GCP HTTP python functions.
  - The functions will simply be calling the broker api & directly integrating our business logic
    meaning we can test both together without much fuss.
  - Adds more work since we will have to convert the functions & create the business logic as follows:

    The generated routes would be converted into `requests` api calls, allowing us to call the api from
    our gcp functions.We could then build the business logic around the api calls on the
    server-side within other gcp functions.

    For example, this is the code generated for getting all accounts.

    ```python
    @app.get('/accounts', response_model=List[Account])
    def get_accounts(query: Optional[str] = None) -> List[Account]:
        """
        Retrieve all accounts
        """
        pass
    ```

    We could convert this to a gcp function to be called from the client-side as follows:

    ```python
    def get_accounts(query: Optional[str] = None) -> List[Account]:
        """
        Retrieve all accounts
        """
        r = requests.get(f'{base_url}/accounts?{query}', auth=('user', 'pass'))

        # Handle bad response
        if r.status_code in (400, 401, 403):
            # do something clever

        return r.json()
    ```

---

## Why not use the python client generated by openapi-codegen?

We have two different sets of code generated for python, one for the server & one for the client. The former has been generated to use `fastapi`, which we will not be using as we do not want to host it. But the syntax of `fastapi` allows for really easy conversion of server code into GCP function calls which we can then wrap with business logic.

The client code generated, however, has execellent structure, tests & docs all pre-generated. The code could simply be kept while we adopt the server-side code to match the structure and docs.

Some other problems with the client generated code.

- ### Boiler Plate

  The code generated contains **ALOT** of boiler plate code, but it does have execellent docs & test structure.
  See `alpaca/broker/client` folder for both typescript and python implementations.

- ### Too general

  Also the generated code is created to be used across many different python versions (even Python 2). We do not need this overhead since we will be writing the functions in Python 3.9.

- ### Ecosystem for verification
  The classes generated by the swagger code gen are also standard Python classes which removes the dependency on other libraries, but `pydantic` is an execellent tool for data verification & allows us to easily implement more checks.
