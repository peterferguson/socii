/* tslint:disable */
/* eslint-disable */
/**
 * Alpaca Broker API
 * Open brokerage accounts, enable commission-free trading, and manage the ongoing user experience with Alpaca Broker API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  Account,
  AccountCreationObject,
  AccountCreationObjectToJSON,
  AccountExtended,
  AccountExtendedFromJSON,
  AccountFromJSON,
  AccountUpdate,
  AccountUpdateToJSON,
  ACHRelationshipData,
  ACHRelationshipDataToJSON,
  ACHRelationshipResource,
  ACHRelationshipResourceFromJSON,
  ActivityItem,
  ActivityItemFromJSON,
  BankData,
  BankDataToJSON,
  BankResource,
  BankResourceFromJSON,
  DocumentUpload,
  DocumentUploadToJSON,
  InlineResponse200,
  InlineResponse2004,
  InlineResponse2004FromJSON,
  InlineResponse200FromJSON,
  TransferData,
  TransferDataToJSON,
  TransferResource,
  TransferResourceFromJSON,
} from "../models"
import * as runtime from "../runtime"

export interface AccountsAccountIdDocumentsUploadPostRequest {
  accountId: string
  documentUpload: DocumentUpload
}

export interface AccountsActivitiesActivityTypeGetRequest {
  activityType: AccountsActivitiesActivityTypeGetActivityTypeEnum
  date?: string
  until?: string
  after?: string
  direction?: AccountsActivitiesActivityTypeGetDirectionEnum
  accountId?: string
  pageSize?: number
  pageToken?: string
}

export interface AccountsActivitiesGetRequest {
  date?: string
  until?: string
  after?: string
  direction?: AccountsActivitiesGetDirectionEnum
  accountId?: string
  pageSize?: number
  pageToken?: string
}

export interface AccountsGetRequest {
  query?: string
}

export interface AccountsPostRequest {
  accountCreationObject: AccountCreationObject
}

export interface DeleteAccountRequest {
  accountId: string
}

export interface DeleteAchRelationshipRequest {
  accountId: string
  achRelationshipId: string
}

export interface DeleteRecipientBankRequest {
  accountId: string
  bankId: string
}

export interface DeleteTransferRequest {
  accountId: string
  transferId: string
}

export interface EventsAccountsStatusGetRequest {
  since?: Date
  until?: Date
  sinceId?: number
  untilId?: number
}

export interface GetAccountRequest {
  accountId: string
}

export interface GetAchRelationshipsRequest {
  accountId: string
  statuses?: string
}

export interface GetRecipientBanksRequest {
  accountId: string
  status?: string
  bankName?: string
}

export interface GetTradingAccountRequest {
  accountId: string
}

export interface GetTransfersRequest {
  accountId: string
  direction?: GetTransfersDirectionEnum
  limit?: number
  offset?: number
}

export interface PatchAccountRequest {
  accountId: string
  accountUpdate: AccountUpdate
}

export interface PostAchRelationshipsRequest {
  accountId: string
  aCHRelationshipData: ACHRelationshipData
}

export interface PostRecipientBanksRequest {
  accountId: string
  bankData: BankData
}

export interface PostTransfersRequest {
  accountId: string
  transferData: TransferData
}

/**
 *
 */
export class AccountsApi extends runtime.BaseAPI {
  /**
   * Upload a document to an already existing account
   */
  async accountsAccountIdDocumentsUploadPostRaw(
    requestParameters: AccountsAccountIdDocumentsUploadPostRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling accountsAccountIdDocumentsUploadPost."
      )
    }

    if (
      requestParameters.documentUpload === null ||
      requestParameters.documentUpload === undefined
    ) {
      throw new runtime.RequiredError(
        "documentUpload",
        "Required parameter requestParameters.documentUpload was null or undefined when calling accountsAccountIdDocumentsUploadPost."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/documents/upload`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: DocumentUploadToJSON(requestParameters.documentUpload),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Upload a document to an already existing account
   */
  async accountsAccountIdDocumentsUploadPost(
    requestParameters: AccountsAccountIdDocumentsUploadPostRequest
  ): Promise<void> {
    await this.accountsAccountIdDocumentsUploadPostRaw(requestParameters)
  }

  /**
   * Retrieve specific account activities
   */
  async accountsActivitiesActivityTypeGetRaw(
    requestParameters: AccountsActivitiesActivityTypeGetRequest
  ): Promise<runtime.ApiResponse<Array<ActivityItem>>> {
    if (
      requestParameters.activityType === null ||
      requestParameters.activityType === undefined
    ) {
      throw new runtime.RequiredError(
        "activityType",
        "Required parameter requestParameters.activityType was null or undefined when calling accountsActivitiesActivityTypeGet."
      )
    }

    const queryParameters: any = {}

    if (requestParameters.date !== undefined) {
      queryParameters["date"] = requestParameters.date
    }

    if (requestParameters.until !== undefined) {
      queryParameters["until"] = requestParameters.until
    }

    if (requestParameters.after !== undefined) {
      queryParameters["after"] = requestParameters.after
    }

    if (requestParameters.direction !== undefined) {
      queryParameters["direction"] = requestParameters.direction
    }

    if (requestParameters.accountId !== undefined) {
      queryParameters["account_id"] = requestParameters.accountId
    }

    if (requestParameters.pageSize !== undefined) {
      queryParameters["page_size"] = requestParameters.pageSize
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["page_token"] = requestParameters.pageToken
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/activities/{activity_type}`.replace(
        `{${"activity_type"}}`,
        encodeURIComponent(String(requestParameters.activityType))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(ActivityItemFromJSON)
    )
  }

  /**
   * Retrieve specific account activities
   */
  async accountsActivitiesActivityTypeGet(
    requestParameters: AccountsActivitiesActivityTypeGetRequest
  ): Promise<Array<ActivityItem>> {
    const response = await this.accountsActivitiesActivityTypeGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Retrieve account activities
   */
  async accountsActivitiesGetRaw(
    requestParameters: AccountsActivitiesGetRequest
  ): Promise<runtime.ApiResponse<Array<ActivityItem>>> {
    const queryParameters: any = {}

    if (requestParameters.date !== undefined) {
      queryParameters["date"] = requestParameters.date
    }

    if (requestParameters.until !== undefined) {
      queryParameters["until"] = requestParameters.until
    }

    if (requestParameters.after !== undefined) {
      queryParameters["after"] = requestParameters.after
    }

    if (requestParameters.direction !== undefined) {
      queryParameters["direction"] = requestParameters.direction
    }

    if (requestParameters.accountId !== undefined) {
      queryParameters["account_id"] = requestParameters.accountId
    }

    if (requestParameters.pageSize !== undefined) {
      queryParameters["page_size"] = requestParameters.pageSize
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["page_token"] = requestParameters.pageToken
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/activities`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(ActivityItemFromJSON)
    )
  }

  /**
   * Retrieve account activities
   */
  async accountsActivitiesGet(
    requestParameters: AccountsActivitiesGetRequest
  ): Promise<Array<ActivityItem>> {
    const response = await this.accountsActivitiesGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Retrieve all accounts
   */
  async accountsGetRaw(
    requestParameters: AccountsGetRequest
  ): Promise<runtime.ApiResponse<Array<Account>>> {
    const queryParameters: any = {}

    if (requestParameters.query !== undefined) {
      queryParameters["query"] = requestParameters.query
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(AccountFromJSON)
    )
  }

  /**
   * Retrieve all accounts
   */
  async accountsGet(requestParameters: AccountsGetRequest): Promise<Array<Account>> {
    const response = await this.accountsGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Create an account
   */
  async accountsPostRaw(
    requestParameters: AccountsPostRequest
  ): Promise<runtime.ApiResponse<Account>> {
    if (
      requestParameters.accountCreationObject === null ||
      requestParameters.accountCreationObject === undefined
    ) {
      throw new runtime.RequiredError(
        "accountCreationObject",
        "Required parameter requestParameters.accountCreationObject was null or undefined when calling accountsPost."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AccountCreationObjectToJSON(requestParameters.accountCreationObject),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AccountFromJSON(jsonValue)
    )
  }

  /**
   * Create an account
   */
  async accountsPost(requestParameters: AccountsPostRequest): Promise<Account> {
    const response = await this.accountsPostRaw(requestParameters)
    return await response.value()
  }

  /**
   * Request to close an account
   */
  async deleteAccountRaw(
    requestParameters: DeleteAccountRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling deleteAccount."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Request to close an account
   */
  async deleteAccount(requestParameters: DeleteAccountRequest): Promise<void> {
    await this.deleteAccountRaw(requestParameters)
  }

  /**
   * Delete an existing ACH relationship
   */
  async deleteAchRelationshipRaw(
    requestParameters: DeleteAchRelationshipRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling deleteAchRelationship."
      )
    }

    if (
      requestParameters.achRelationshipId === null ||
      requestParameters.achRelationshipId === undefined
    ) {
      throw new runtime.RequiredError(
        "achRelationshipId",
        "Required parameter requestParameters.achRelationshipId was null or undefined when calling deleteAchRelationship."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/ach_relationships/{ach_relationship_id}`
        .replace(
          `{${"account_id"}}`,
          encodeURIComponent(String(requestParameters.accountId))
        )
        .replace(
          `{${"ach_relationship_id"}}`,
          encodeURIComponent(String(requestParameters.achRelationshipId))
        ),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete an existing ACH relationship
   */
  async deleteAchRelationship(
    requestParameters: DeleteAchRelationshipRequest
  ): Promise<void> {
    await this.deleteAchRelationshipRaw(requestParameters)
  }

  /**
   * Delete a Bank Relationship for an account
   */
  async deleteRecipientBankRaw(
    requestParameters: DeleteRecipientBankRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling deleteRecipientBank."
      )
    }

    if (requestParameters.bankId === null || requestParameters.bankId === undefined) {
      throw new runtime.RequiredError(
        "bankId",
        "Required parameter requestParameters.bankId was null or undefined when calling deleteRecipientBank."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/recipient_banks/{bank_id}`
        .replace(
          `{${"account_id"}}`,
          encodeURIComponent(String(requestParameters.accountId))
        )
        .replace(
          `{${"bank_id"}}`,
          encodeURIComponent(String(requestParameters.bankId))
        ),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a Bank Relationship for an account
   */
  async deleteRecipientBank(
    requestParameters: DeleteRecipientBankRequest
  ): Promise<void> {
    await this.deleteRecipientBankRaw(requestParameters)
  }

  /**
   * Request to close a transfer
   */
  async deleteTransferRaw(
    requestParameters: DeleteTransferRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling deleteTransfer."
      )
    }

    if (
      requestParameters.transferId === null ||
      requestParameters.transferId === undefined
    ) {
      throw new runtime.RequiredError(
        "transferId",
        "Required parameter requestParameters.transferId was null or undefined when calling deleteTransfer."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/transfers/{transfer_id}`
        .replace(
          `{${"account_id"}}`,
          encodeURIComponent(String(requestParameters.accountId))
        )
        .replace(
          `{${"transfer_id"}}`,
          encodeURIComponent(String(requestParameters.transferId))
        ),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Request to close a transfer
   */
  async deleteTransfer(requestParameters: DeleteTransferRequest): Promise<void> {
    await this.deleteTransferRaw(requestParameters)
  }

  /**
   * Query Params Rules: - `since` required if `until` specified - `since_id` required if `until_id` specified - `since` and `since_id` can’t be used at the same time Behavior: - if `since` or `since_id` not specified this will not return any historic data - if `until` or `until_id` reached stream will end (status 200)
   * Subscribe to account status events (SSE).
   */
  async eventsAccountsStatusGetRaw(
    requestParameters: EventsAccountsStatusGetRequest
  ): Promise<runtime.ApiResponse<InlineResponse2004>> {
    const queryParameters: any = {}

    if (requestParameters.since !== undefined) {
      queryParameters["since"] = (requestParameters.since as any).toISOString()
    }

    if (requestParameters.until !== undefined) {
      queryParameters["until"] = (requestParameters.until as any).toISOString()
    }

    if (requestParameters.sinceId !== undefined) {
      queryParameters["since_id"] = requestParameters.sinceId
    }

    if (requestParameters.untilId !== undefined) {
      queryParameters["until_id"] = requestParameters.untilId
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/events/accounts/status`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse2004FromJSON(jsonValue)
    )
  }

  /**
   * Query Params Rules: - `since` required if `until` specified - `since_id` required if `until_id` specified - `since` and `since_id` can’t be used at the same time Behavior: - if `since` or `since_id` not specified this will not return any historic data - if `until` or `until_id` reached stream will end (status 200)
   * Subscribe to account status events (SSE).
   */
  async eventsAccountsStatusGet(
    requestParameters: EventsAccountsStatusGetRequest
  ): Promise<InlineResponse2004> {
    const response = await this.eventsAccountsStatusGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * The response is an Account model.
   * Retrieve an account.
   */
  async getAccountRaw(
    requestParameters: GetAccountRequest
  ): Promise<runtime.ApiResponse<AccountExtended>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling getAccount."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AccountExtendedFromJSON(jsonValue)
    )
  }

  /**
   * The response is an Account model.
   * Retrieve an account.
   */
  async getAccount(requestParameters: GetAccountRequest): Promise<AccountExtended> {
    const response = await this.getAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * Retrieve ACH Relationships for an account
   */
  async getAchRelationshipsRaw(
    requestParameters: GetAchRelationshipsRequest
  ): Promise<runtime.ApiResponse<Array<ACHRelationshipResource>>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling getAchRelationships."
      )
    }

    const queryParameters: any = {}

    if (requestParameters.statuses !== undefined) {
      queryParameters["statuses"] = requestParameters.statuses
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/ach_relationships`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(ACHRelationshipResourceFromJSON)
    )
  }

  /**
   * Retrieve ACH Relationships for an account
   */
  async getAchRelationships(
    requestParameters: GetAchRelationshipsRequest
  ): Promise<Array<ACHRelationshipResource>> {
    const response = await this.getAchRelationshipsRaw(requestParameters)
    return await response.value()
  }

  /**
   * Retrieve bank relationships for an account
   */
  async getRecipientBanksRaw(
    requestParameters: GetRecipientBanksRequest
  ): Promise<runtime.ApiResponse<Array<BankResource>>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling getRecipientBanks."
      )
    }

    const queryParameters: any = {}

    if (requestParameters.status !== undefined) {
      queryParameters["status"] = requestParameters.status
    }

    if (requestParameters.bankName !== undefined) {
      queryParameters["bank_name"] = requestParameters.bankName
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/recipient_banks`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(BankResourceFromJSON)
    )
  }

  /**
   * Retrieve bank relationships for an account
   */
  async getRecipientBanks(
    requestParameters: GetRecipientBanksRequest
  ): Promise<Array<BankResource>> {
    const response = await this.getRecipientBanksRaw(requestParameters)
    return await response.value()
  }

  /**
   * The response is a Trading Account model.
   * Retrieve trading details for an account.
   */
  async getTradingAccountRaw(
    requestParameters: GetTradingAccountRequest
  ): Promise<runtime.ApiResponse<InlineResponse200>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling getTradingAccount."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/trading/accounts/{account_id}/account`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse200FromJSON(jsonValue)
    )
  }

  /**
   * The response is a Trading Account model.
   * Retrieve trading details for an account.
   */
  async getTradingAccount(
    requestParameters: GetTradingAccountRequest
  ): Promise<InlineResponse200> {
    const response = await this.getTradingAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * You can filter requested transfers by values such as direction and status.
   * Return a list of transfers for an account.
   */
  async getTransfersRaw(
    requestParameters: GetTransfersRequest
  ): Promise<runtime.ApiResponse<Array<TransferResource>>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling getTransfers."
      )
    }

    const queryParameters: any = {}

    if (requestParameters.direction !== undefined) {
      queryParameters["direction"] = requestParameters.direction
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit
    }

    if (requestParameters.offset !== undefined) {
      queryParameters["offset"] = requestParameters.offset
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/transfers`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(TransferResourceFromJSON)
    )
  }

  /**
   * You can filter requested transfers by values such as direction and status.
   * Return a list of transfers for an account.
   */
  async getTransfers(
    requestParameters: GetTransfersRequest
  ): Promise<Array<TransferResource>> {
    const response = await this.getTransfersRaw(requestParameters)
    return await response.value()
  }

  /**
   * Update an account
   */
  async patchAccountRaw(
    requestParameters: PatchAccountRequest
  ): Promise<runtime.ApiResponse<Account>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling patchAccount."
      )
    }

    if (
      requestParameters.accountUpdate === null ||
      requestParameters.accountUpdate === undefined
    ) {
      throw new runtime.RequiredError(
        "accountUpdate",
        "Required parameter requestParameters.accountUpdate was null or undefined when calling patchAccount."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: AccountUpdateToJSON(requestParameters.accountUpdate),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AccountFromJSON(jsonValue)
    )
  }

  /**
   * Update an account
   */
  async patchAccount(requestParameters: PatchAccountRequest): Promise<Account> {
    const response = await this.patchAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * Create an ACH Relationship
   */
  async postAchRelationshipsRaw(
    requestParameters: PostAchRelationshipsRequest
  ): Promise<runtime.ApiResponse<ACHRelationshipResource>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling postAchRelationships."
      )
    }

    if (
      requestParameters.aCHRelationshipData === null ||
      requestParameters.aCHRelationshipData === undefined
    ) {
      throw new runtime.RequiredError(
        "aCHRelationshipData",
        "Required parameter requestParameters.aCHRelationshipData was null or undefined when calling postAchRelationships."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/ach_relationships`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ACHRelationshipDataToJSON(requestParameters.aCHRelationshipData),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ACHRelationshipResourceFromJSON(jsonValue)
    )
  }

  /**
   * Create an ACH Relationship
   */
  async postAchRelationships(
    requestParameters: PostAchRelationshipsRequest
  ): Promise<ACHRelationshipResource> {
    const response = await this.postAchRelationshipsRaw(requestParameters)
    return await response.value()
  }

  /**
   * Create a Bank Relationship for an account
   */
  async postRecipientBanksRaw(
    requestParameters: PostRecipientBanksRequest
  ): Promise<runtime.ApiResponse<BankResource>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling postRecipientBanks."
      )
    }

    if (
      requestParameters.bankData === null ||
      requestParameters.bankData === undefined
    ) {
      throw new runtime.RequiredError(
        "bankData",
        "Required parameter requestParameters.bankData was null or undefined when calling postRecipientBanks."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/recipient_banks`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: BankDataToJSON(requestParameters.bankData),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      BankResourceFromJSON(jsonValue)
    )
  }

  /**
   * Create a Bank Relationship for an account
   */
  async postRecipientBanks(
    requestParameters: PostRecipientBanksRequest
  ): Promise<BankResource> {
    const response = await this.postRecipientBanksRaw(requestParameters)
    return await response.value()
  }

  /**
   * This operation allows you to fund an account with virtual money in the sandbox environment.
   * Request a new transfer
   */
  async postTransfersRaw(
    requestParameters: PostTransfersRequest
  ): Promise<runtime.ApiResponse<TransferResource>> {
    if (
      requestParameters.accountId === null ||
      requestParameters.accountId === undefined
    ) {
      throw new runtime.RequiredError(
        "accountId",
        "Required parameter requestParameters.accountId was null or undefined when calling postTransfers."
      )
    }

    if (
      requestParameters.transferData === null ||
      requestParameters.transferData === undefined
    ) {
      throw new runtime.RequiredError(
        "transferData",
        "Required parameter requestParameters.transferData was null or undefined when calling postTransfers."
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password)
    }
    const response = await this.request({
      path: `/accounts/{account_id}/transfers`.replace(
        `{${"account_id"}}`,
        encodeURIComponent(String(requestParameters.accountId))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TransferDataToJSON(requestParameters.transferData),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      TransferResourceFromJSON(jsonValue)
    )
  }

  /**
   * This operation allows you to fund an account with virtual money in the sandbox environment.
   * Request a new transfer
   */
  async postTransfers(
    requestParameters: PostTransfersRequest
  ): Promise<TransferResource> {
    const response = await this.postTransfersRaw(requestParameters)
    return await response.value()
  }
}

/**
 * @export
 * @enum {string}
 */
export enum AccountsActivitiesActivityTypeGetActivityTypeEnum {
  Fill = "FILL",
  Acatc = "ACATC",
  Acats = "ACATS",
  Csd = "CSD",
  Csr = "CSR",
  Csw = "CSW",
  Div = "DIV",
  Divcgl = "DIVCGL",
  Divcgs = "DIVCGS",
  Divnra = "DIVNRA",
  Divroc = "DIVROC",
  Divtxex = "DIVTXEX",
  Int = "INT",
  Jnlc = "JNLC",
  Jnls = "JNLS",
  Ma = "MA",
  Nc = "NC",
  Ptc = "PTC",
  Reorg = "REORG",
  Sso = "SSO",
  Ssp = "SSP",
}
/**
 * @export
 * @enum {string}
 */
export enum AccountsActivitiesActivityTypeGetDirectionEnum {
  Asc = "asc",
  Desc = "desc",
}
/**
 * @export
 * @enum {string}
 */
export enum AccountsActivitiesGetDirectionEnum {
  Asc = "asc",
  Desc = "desc",
}
/**
 * @export
 * @enum {string}
 */
export enum GetTransfersDirectionEnum {
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
}
