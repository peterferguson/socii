/* tslint:disable */
/* eslint-disable */
/**
 * Alpaca Broker API
 * Open brokerage accounts, enable commission-free trading, and manage the ongoing user experience with Alpaca Broker API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BatchJournalRequest,
    BatchJournalRequestFromJSON,
    BatchJournalRequestToJSON,
    BatchJournalResponse,
    BatchJournalResponseFromJSON,
    BatchJournalResponseToJSON,
    InlineResponse2005,
    InlineResponse2005FromJSON,
    InlineResponse2005ToJSON,
    JournalData,
    JournalDataFromJSON,
    JournalDataToJSON,
    JournalResource,
    JournalResourceFromJSON,
    JournalResourceToJSON,
} from '../models';

export interface DeleteJournalRequest {
    journalId: string;
}

export interface EventsJournalsStatusGetRequest {
    since?: Date;
    until?: Date;
    sinceId?: number;
    untilId?: number;
}

export interface GetJournalsRequest {
    after?: Date;
    before?: Date;
    status?: GetJournalsStatusEnum;
    entryType?: GetJournalsEntryTypeEnum;
    toAccount?: string;
    fromAccount?: string;
}

export interface PostJournalsRequest {
    journalData: JournalData;
}

export interface PostJournalsBatchRequest {
    batchJournalRequest: BatchJournalRequest;
}

/**
 * 
 */
export class JournalsApi extends runtime.BaseAPI {

    /**
     * You can cancel journals while they are in the pending status. An attempt to cancel already-executed journals will return an error. 
     * Cancel a pending journal.
     */
    async deleteJournalRaw(requestParameters: DeleteJournalRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.journalId === null || requestParameters.journalId === undefined) {
            throw new runtime.RequiredError('journalId','Required parameter requestParameters.journalId was null or undefined when calling deleteJournal.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/journals/{journal_id}`.replace(`{${"journal_id"}}`, encodeURIComponent(String(requestParameters.journalId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * You can cancel journals while they are in the pending status. An attempt to cancel already-executed journals will return an error. 
     * Cancel a pending journal.
     */
    async deleteJournal(requestParameters: DeleteJournalRequest): Promise<void> {
        await this.deleteJournalRaw(requestParameters);
    }

    /**
     * Query Params Rules: - `since` required if `until` specified - `since_id` required if `until_id` specified - `since` and `since_id` can’t be used at the same time Behavior: - if `since` or `since_id` not specified this will not return any historic data - if `until` or `until_id` reached stream will end (status 200) 
     * Subscribe to journal events (SSE).
     */
    async eventsJournalsStatusGetRaw(requestParameters: EventsJournalsStatusGetRequest): Promise<runtime.ApiResponse<InlineResponse2005>> {
        const queryParameters: any = {};

        if (requestParameters.since !== undefined) {
            queryParameters['since'] = (requestParameters.since as any).toISOString();
        }

        if (requestParameters.until !== undefined) {
            queryParameters['until'] = (requestParameters.until as any).toISOString();
        }

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/journals/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2005FromJSON(jsonValue));
    }

    /**
     * Query Params Rules: - `since` required if `until` specified - `since_id` required if `until_id` specified - `since` and `since_id` can’t be used at the same time Behavior: - if `since` or `since_id` not specified this will not return any historic data - if `until` or `until_id` reached stream will end (status 200) 
     * Subscribe to journal events (SSE).
     */
    async eventsJournalsStatusGet(requestParameters: EventsJournalsStatusGetRequest): Promise<InlineResponse2005> {
        const response = await this.eventsJournalsStatusGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Return a list of requested journals.
     */
    async getJournalsRaw(requestParameters: GetJournalsRequest): Promise<runtime.ApiResponse<Array<JournalResource>>> {
        const queryParameters: any = {};

        if (requestParameters.after !== undefined) {
            queryParameters['after'] = (requestParameters.after as any).toISOString().substr(0,10);
        }

        if (requestParameters.before !== undefined) {
            queryParameters['before'] = (requestParameters.before as any).toISOString().substr(0,10);
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.entryType !== undefined) {
            queryParameters['entry_type'] = requestParameters.entryType;
        }

        if (requestParameters.toAccount !== undefined) {
            queryParameters['to_account'] = requestParameters.toAccount;
        }

        if (requestParameters.fromAccount !== undefined) {
            queryParameters['from_account'] = requestParameters.fromAccount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/journals`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(JournalResourceFromJSON));
    }

    /**
     * Return a list of requested journals.
     */
    async getJournals(requestParameters: GetJournalsRequest): Promise<Array<JournalResource>> {
        const response = await this.getJournalsRaw(requestParameters);
        return await response.value();
    }

    /**
     * A journal can be JNLC (move cash) or JNLS (move shares), dictated by `entry_type`. Generally, journal requests are subject to approval and starts from the `pending` status. The status changes are propagated through the Event API. Under certain conditions agreed for the partner, such journal transactions that meet the criteria are executed right away. 
     * Request a journal.
     */
    async postJournalsRaw(requestParameters: PostJournalsRequest): Promise<runtime.ApiResponse<JournalResource>> {
        if (requestParameters.journalData === null || requestParameters.journalData === undefined) {
            throw new runtime.RequiredError('journalData','Required parameter requestParameters.journalData was null or undefined when calling postJournals.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/journals`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: JournalDataToJSON(requestParameters.journalData),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JournalResourceFromJSON(jsonValue));
    }

    /**
     * A journal can be JNLC (move cash) or JNLS (move shares), dictated by `entry_type`. Generally, journal requests are subject to approval and starts from the `pending` status. The status changes are propagated through the Event API. Under certain conditions agreed for the partner, such journal transactions that meet the criteria are executed right away. 
     * Request a journal.
     */
    async postJournals(requestParameters: PostJournalsRequest): Promise<JournalResource> {
        const response = await this.postJournalsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a batch journal
     */
    async postJournalsBatchRaw(requestParameters: PostJournalsBatchRequest): Promise<runtime.ApiResponse<Array<BatchJournalResponse>>> {
        if (requestParameters.batchJournalRequest === null || requestParameters.batchJournalRequest === undefined) {
            throw new runtime.RequiredError('batchJournalRequest','Required parameter requestParameters.batchJournalRequest was null or undefined when calling postJournalsBatch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/journals/batch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BatchJournalRequestToJSON(requestParameters.batchJournalRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BatchJournalResponseFromJSON));
    }

    /**
     * Create a batch journal
     */
    async postJournalsBatch(requestParameters: PostJournalsBatchRequest): Promise<Array<BatchJournalResponse>> {
        const response = await this.postJournalsBatchRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetJournalsStatusEnum {
    Pending = 'pending',
    Canceled = 'canceled',
    Executed = 'executed'
}
/**
    * @export
    * @enum {string}
    */
export enum GetJournalsEntryTypeEnum {
    Jnlc = 'JNLC',
    Jnls = 'JNLS'
}
